# Animals
Java OOP

1) Добавить в класс Animal методы двигаться(toGo), летать(fly), плавать(swim).
2) Создать по два класса
наследника Animal, умеющих летать, плавать, бегать(животное может как уметь что-то одно, так и все сразу).
3) В main добиться того, чтобы при вызове метода действия, которое конкретное животное не умеет, оно этого не делало (кошки не летают, рыбы не ходят)
4) В файле readme.md в репозитории гитхаб описать
какие проблемы в таком проектировании Вы увидели,
а также там же написать возникшие при выполнении дз вопросы
(если они есть)

Формат сдачи:
Ссылка на гитхаб

Решение:
1. Были добавлены методы toGo, toFly и toSwim.
       public void toGo() {
        System.out.println(getType() + " может ходить");
    }

    public void toFly() {
        System.out.println(getType() + " может летать");
    }

    public void toSwim() {
        System.out.println(getType() + " может плавать");
    }
2. Были добавлены новые классы и подклассы. Например, классы Duck и Ostrich являются наследниками класса Bird, FlyingFish является наследником класса Fish, Snake является наследником класса Animal. Но ввиду свойств каждого из новых классов, им приходится переопределять нужные методы, которые наследуются из родительского класса ошибочно.
   Например,
   public class Ostrich extends Bird {
    public Ostrich() {super();}

    public Ostrich(String name, LocalDate birthday, Illness illness, String ownerName) {
        super(name, birthday, illness, ownerName);
    }

    @Override //переопределение метода
    public void toSwim() {
        System.out.println(this.getClass().getSimpleName() + " не может плавать");
    }
    @Override
    public void toFly() {
        System.out.println(this.getClass().getSimpleName() + " не может летать");
    }
4. Чем больше классов мы будем добавлять, тем лучше придется следить за переопределением методов. Альтернативно можно было бы изменить структуру классов. Но чем больше мы будем добавлять методов, тем больше нам придется исправлять и добавлять переопределение методов в каждом из классов. Такое же неидеальное решение было бы, если бы мы в методах основного класса проверяли бы класс текущего экземпляра, поскольку создание новых классов заставляло бы нас заново переделывать и сильно усложнять данные методы.
Решение с некой "матрицей умений", где были бы собраны все возможности классов в виде Boolean переменных с последующей проверкой конкретных умений по индексу, также заставит перебирать все классы и все методы, чтобы выдавались правильные ответы.

Вывод:
Идеального решения нет. Надо стараться подстраивать структуру классов и методов под конкретные условия и требования.
